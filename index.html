<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Triangle Walker - Button Version</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #f4f4f2;
        overflow: hidden;
      }
      canvas {
        display: block;
        position: fixed;
        inset: 0;
      }
      .ui {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 12px;
        z-index: 10;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      }
      button {
        padding: 8px 14px;
        border-radius: 999px;
        border: none;
        background: #111111;
        color: white;
        font-size: 14px;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.4;
        cursor: default;
      }
      .info {
        font-size: 14px;
        color: #111111;
        align-self: center;
      }
    </style>
  </head>
  <body>
    <div class="ui">
      <button id="addJoint">관절 하나 추가하기</button>
      <button id="removeJoint">관절 하나 빼기</button>
      <span class="info" id="jointInfo"></span>
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.164.0/build/three.module.js";

      // === 기본 세팅 ===
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf4f4f2);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const camera = new THREE.OrthographicCamera();
      scene.add(camera);

      function updateCamera() {
        const aspect = window.innerWidth / window.innerHeight;
        const viewSize = 6;
        camera.left   = -viewSize * aspect;
        camera.right  =  viewSize * aspect;
        camera.top    =  viewSize;
        camera.bottom = -viewSize;
        camera.near   = 0.1;
        camera.far    = 100;
        camera.position.set(0, 0, 10);
        camera.lookAt(0, 0, 0);
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      updateCamera();
      window.addEventListener("resize", updateCamera);

      // === 삼각형 지오메트리 & 머티리얼 ===
      function createTriangleGeometry() {
        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
          0,   0, 0,   // 왼쪽 아래(피벗)
          1.0, 0, 0,   // 오른쪽 아래
          0.5, 1.0, 0  // 위
        ]);
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(vertices, 3)
        );
        geometry.computeVertexNormals();
        return geometry;
      }

      const triangleGeometry = createTriangleGeometry();
      const triangleMaterial = new THREE.MeshBasicMaterial({
        color: 0x111111,
        side: THREE.DoubleSide
      });

      // === 워커(관절 체인) ===
      const walkerRoot = new THREE.Group();
      scene.add(walkerRoot);

      let joints = [];
      let currentSegmentCount = 0;
      const segmentConfigs = [];

      const SEGMENT_LENGTH = 1.0;

      const SEGMENT_BLUEPRINTS = [
        {
          name: "pelvis",
          width: 1.3,
          height: 0.9,
          parentIndex: null,
          anchorIndex: null,
          role: "core",
          rotationAmplitude: 0.12,
          rotationSpeed: 1.6,
          wobbleStrength: 0.04,
          wobbleSpeed: 1.2,
          lateralStrength: 0.03,
          baseYOffset: -0.4
        },
        {
          name: "torso",
          width: 1.0,
          height: 1.5,
          parentIndex: 0,
          anchorIndex: 2,
          role: "core",
          rotationAmplitude: 0.18,
          rotationSpeed: 1.8,
          wobbleStrength: 0.05,
          wobbleSpeed: 1.0,
          lateralStrength: 0.02,
          baseYOffset: 0.2
        },
        {
          name: "head",
          width: 0.65,
          height: 0.65,
          parentIndex: 1,
          anchorIndex: 2,
          role: "head",
          rotationAmplitude: 0.2,
          rotationSpeed: 1.4,
          wobbleStrength: 0.05,
          wobbleSpeed: 1.3,
          lateralStrength: 0.02,
          baseYOffset: 0.4
        },
        {
          name: "leftThigh",
          width: 0.35,
          height: 1.4,
          parentIndex: 0,
          anchorIndex: 0,
          role: "legLeft",
          rotationAmplitude: 0.95,
          rotationSpeed: 1.0,
          wobbleStrength: 0.03,
          wobbleSpeed: 1.1,
          lateralStrength: 0.05,
          baseYOffset: -0.1
        },
        {
          name: "rightThigh",
          width: 0.35,
          height: 1.4,
          parentIndex: 0,
          anchorIndex: 1,
          role: "legRight",
          rotationAmplitude: 0.95,
          rotationSpeed: 1.0,
          wobbleStrength: 0.03,
          wobbleSpeed: 1.1,
          lateralStrength: 0.05,
          baseYOffset: -0.1
        },
        {
          name: "leftShin",
          width: 0.3,
          height: 1.15,
          parentIndex: 3,
          anchorIndex: 2,
          role: "legLeft",
          rotationAmplitude: 0.7,
          rotationSpeed: 1.0,
          wobbleStrength: 0.02,
          wobbleSpeed: 1.0,
          lateralStrength: 0.04,
          baseYOffset: -0.05
        },
        {
          name: "rightShin",
          width: 0.3,
          height: 1.15,
          parentIndex: 4,
          anchorIndex: 2,
          role: "legRight",
          rotationAmplitude: 0.7,
          rotationSpeed: 1.0,
          wobbleStrength: 0.02,
          wobbleSpeed: 1.0,
          lateralStrength: 0.04,
          baseYOffset: -0.05
        },
        {
          name: "leftArm",
          width: 0.3,
          height: 1.0,
          parentIndex: 1,
          anchorIndex: 3,
          role: "armLeft",
          rotationAmplitude: 0.55,
          rotationSpeed: 1.0,
          wobbleStrength: 0.03,
          wobbleSpeed: 1.2,
          lateralStrength: 0.04,
          baseYOffset: 0.25
        },
        {
          name: "rightArm",
          width: 0.3,
          height: 1.0,
          parentIndex: 1,
          anchorIndex: 4,
          role: "armRight",
          rotationAmplitude: 0.55,
          rotationSpeed: 1.0,
          wobbleStrength: 0.03,
          wobbleSpeed: 1.2,
          lateralStrength: 0.04,
          baseYOffset: 0.25
        },
        {
          name: "leftForearm",
          width: 0.25,
          height: 0.85,
          parentIndex: 7,
          anchorIndex: 2,
          role: "armLeft",
          rotationAmplitude: 0.45,
          rotationSpeed: 1.0,
          wobbleStrength: 0.02,
          wobbleSpeed: 1.2,
          lateralStrength: 0.03,
          baseYOffset: 0
        },
        {
          name: "rightForearm",
          width: 0.25,
          height: 0.85,
          parentIndex: 8,
          anchorIndex: 2,
          role: "armRight",
          rotationAmplitude: 0.45,
          rotationSpeed: 1.0,
          wobbleStrength: 0.02,
          wobbleSpeed: 1.2,
          lateralStrength: 0.03,
          baseYOffset: 0
        },
        {
          name: "upperTorso",
          width: 0.85,
          height: 1.05,
          parentIndex: 1,
          anchorIndex: 2,
          role: "core",
          rotationAmplitude: 0.15,
          rotationSpeed: 1.6,
          wobbleStrength: 0.04,
          wobbleSpeed: 1.1,
          lateralStrength: 0.02,
          baseYOffset: 0.5
        }
      ];

      const MIN_SEGMENTS = 1;
      const MAX_SEGMENTS = SEGMENT_BLUEPRINTS.length;

      function clearWalker() {
        walkerRoot.children.slice().forEach(child => {
          walkerRoot.remove(child);
        });
        joints = [];
      }

      function randomInRange(min, max) {
        return min + Math.random() * (max - min);
      }

      function ensureSegmentConfigs(count) {
        if (segmentConfigs.length > count) {
          segmentConfigs.length = count;
        }
        for (let i = 0; i < count; i++) {
          if (segmentConfigs[i]) continue;
          const blueprint = SEGMENT_BLUEPRINTS[i] || SEGMENT_BLUEPRINTS[SEGMENT_BLUEPRINTS.length - 1];
          const config = {
            ...blueprint,
            width: blueprint.width * randomInRange(0.95, 1.05),
            height: blueprint.height * randomInRange(0.92, 1.08),
            rotationSpeed: blueprint.rotationSpeed + randomInRange(-0.2, 0.2),
            rotationAmplitude: blueprint.rotationAmplitude + randomInRange(-0.05, 0.05),
            wobbleSpeed: blueprint.wobbleSpeed + randomInRange(-0.2, 0.2),
            wobbleStrength: Math.max(0, blueprint.wobbleStrength + randomInRange(-0.01, 0.01)),
            lateralStrength: Math.max(0, blueprint.lateralStrength + randomInRange(-0.01, 0.01)),
            phase: Math.random() * Math.PI * 2
          };
          segmentConfigs[i] = config;
        }
      }

      function createAnchors(widthScale, heightScale) {
        const anchors = [
          new THREE.Group(),
          new THREE.Group(),
          new THREE.Group(),
          new THREE.Group(),
          new THREE.Group()
        ];
        const width = widthScale * SEGMENT_LENGTH;
        anchors[0].position.set(0, 0, 0);
        anchors[1].position.set(width, 0, 0);
        anchors[2].position.set(width * 0.5, heightScale, 0);
        anchors[3].position.set(width * 0.2, heightScale * 0.75, 0);
        anchors[4].position.set(width * 0.8, heightScale * 0.75, 0);
        return anchors;
      }

      function buildWalker(segmentCount) {
        clearWalker();
        ensureSegmentConfigs(segmentCount);

        for (let i = 0; i < segmentCount; i++) {
          const config = segmentConfigs[i];
          const joint = new THREE.Group();
          joint.position.set(0, 0, 0);

          const mesh = new THREE.Mesh(triangleGeometry, triangleMaterial);
          const { width, height } = config;
          mesh.scale.set(width * SEGMENT_LENGTH, height, 1.0);
          mesh.position.set(0, 0, 0);

          joint.add(mesh);

          const anchors = createAnchors(width, height);
          anchors.forEach(anchor => joint.add(anchor));
          joint.userData.anchors = anchors;
          joint.userData.config = config;
          joint.userData.role = config.role;
          joint.userData.offset = {
            x: (config.baseOffsetX || 0) + (Math.random() - 0.5) * 0.02,
            y: config.baseYOffset || 0
          };

          const parentIndex = config.parentIndex;
          if (parentIndex === null || parentIndex === undefined) {
            walkerRoot.add(joint);
          } else {
            const parentJoint = joints[parentIndex];
            const anchorIndex = config.anchorIndex ?? 2;
            const parentAnchor =
              parentJoint?.userData.anchors[anchorIndex] || parentJoint || walkerRoot;
            parentAnchor.add(joint);
          }

          joints.push(joint);
        }

        currentSegmentCount = segmentCount;
        updateUI();
      }

      // === UI ===
      const addButton = document.getElementById("addJoint");
      const removeButton = document.getElementById("removeJoint");
      const jointInfo = document.getElementById("jointInfo");

      function updateUI() {
        jointInfo.textContent = `관절 개수: ${currentSegmentCount}`;
        addButton.disabled = currentSegmentCount >= MAX_SEGMENTS;
        removeButton.disabled = currentSegmentCount <= MIN_SEGMENTS;
      }

      addButton.addEventListener("click", () => {
        if (currentSegmentCount < MAX_SEGMENTS) {
          buildWalker(currentSegmentCount + 1);
        }
      });

      removeButton.addEventListener("click", () => {
        if (currentSegmentCount > MIN_SEGMENTS) {
          buildWalker(currentSegmentCount - 1);
        }
      });

      // 초기 상태: 힘겹게 걷는 느낌 (관절 적게)
      buildWalker(MIN_SEGMENTS);

      // === 애니메이션 루프 ===
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);

        const t = clock.getElapsedTime();

        // 워커 전체 위치 및 롤링
        const travelSpeed = 1.2;
        const loopWidth = 12;
        const strideSpeed = 2.4;
        const stridePhase = t * strideSpeed;
        walkerRoot.position.x = ((t * travelSpeed) % loopWidth) - loopWidth / 2;
        walkerRoot.position.y = -1.5 + Math.sin(stridePhase) * 0.28;
        walkerRoot.rotation.z = Math.sin(stridePhase) * 0.08;
        walkerRoot.rotation.x = Math.sin(stridePhase * 0.5) * 0.05;

        joints.forEach(joint => {
          const config = joint.userData.config;
          if (!config) return;

          let rotation = 0;
          switch (config.role) {
            case "legLeft":
              rotation = Math.sin(stridePhase) * config.rotationAmplitude;
              break;
            case "legRight":
              rotation = Math.sin(stridePhase + Math.PI) * config.rotationAmplitude;
              break;
            case "armLeft":
              rotation = Math.sin(stridePhase + Math.PI) * config.rotationAmplitude;
              break;
            case "armRight":
              rotation = Math.sin(stridePhase) * config.rotationAmplitude;
              break;
            case "head":
              rotation =
                Math.sin(t * config.rotationSpeed + config.phase) *
                  config.rotationAmplitude * 0.6 +
                Math.sin(stridePhase) * 0.05;
              break;
            default:
              rotation =
                Math.sin(t * config.rotationSpeed + config.phase) *
                config.rotationAmplitude;
              break;
          }

          joint.rotation.z = rotation;

          const wobblePhase = t * config.wobbleSpeed + config.phase;
          const wobbleY = Math.sin(wobblePhase) * config.wobbleStrength;
          const wobbleX = Math.cos(wobblePhase) * config.lateralStrength;

          let gaitLift = 0;
          if (config.role === "legLeft") {
            gaitLift = Math.max(0, Math.sin(stridePhase + Math.PI / 2));
          } else if (config.role === "legRight") {
            gaitLift = Math.max(0, Math.sin(stridePhase + Math.PI * 1.5));
          }

          joint.position.y =
            (joint.userData.offset?.y || 0) + wobbleY + gaitLift * 0.15;
          joint.position.x = (joint.userData.offset?.x || 0) + wobbleX;
        });

        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
