<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Triangle Walker - Button Version</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #f4f4f2;
        overflow: hidden;
      }
      canvas {
        display: block;
        position: fixed;
        inset: 0;
      }
      .ui {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 12px;
        z-index: 10;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      }
      button {
        padding: 8px 14px;
        border-radius: 999px;
        border: none;
        background: #111111;
        color: white;
        font-size: 14px;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.4;
        cursor: default;
      }
      .info {
        font-size: 14px;
        color: #111111;
        align-self: center;
      }
    </style>
  </head>
  <body>
    <div class="ui">
      <button id="addJoint">관절 하나 추가하기</button>
      <button id="removeJoint">관절 하나 빼기</button>
      <span class="info" id="jointInfo"></span>
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.164.0/build/three.module.js";

      // === 기본 세팅 ===
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf4f4f2);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const camera = new THREE.OrthographicCamera();
      scene.add(camera);

      function updateCamera() {
        const aspect = window.innerWidth / window.innerHeight;
        const viewSize = 6;
        camera.left   = -viewSize * aspect;
        camera.right  =  viewSize * aspect;
        camera.top    =  viewSize;
        camera.bottom = -viewSize;
        camera.near   = 0.1;
        camera.far    = 100;
        camera.position.set(0, 0, 10);
        camera.lookAt(0, 0, 0);
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      updateCamera();
      window.addEventListener("resize", updateCamera);

      // === 삼각형 지오메트리 & 머티리얼 ===
      function createTriangleGeometry() {
        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
          0,   0, 0,   // 왼쪽 아래(피벗)
          1.0, 0, 0,   // 오른쪽 아래
          0.5, 1.0, 0  // 위
        ]);
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(vertices, 3)
        );
        geometry.computeVertexNormals();
        return geometry;
      }

      const triangleGeometry = createTriangleGeometry();
      const triangleMaterial = new THREE.MeshBasicMaterial({
        color: 0x111111,
        side: THREE.DoubleSide
      });

      // === 워커(관절 체인) ===
      const walkerRoot = new THREE.Group();
      scene.add(walkerRoot);

      let joints = [];
      let currentSegmentCount = 0;
      const segmentScales = [];

      const MIN_SEGMENTS = 2;
      const MAX_SEGMENTS = 12;
      const SEGMENT_LENGTH = 1.0;

      function clearWalker() {
        walkerRoot.children.slice().forEach(child => {
          walkerRoot.remove(child);
        });
        joints = [];
      }

      function randomInRange(min, max) {
        return min + Math.random() * (max - min);
      }

      function ensureSegmentScales(count) {
        if (segmentScales.length > count) {
          segmentScales.length = count;
        }
        while (segmentScales.length < count) {
          segmentScales.push({
            width: randomInRange(0.7, 1.3),
            height: randomInRange(0.7, 1.6)
          });
        }
      }

      function buildWalker(segmentCount) {
        clearWalker();
        ensureSegmentScales(segmentCount);

        let parent = walkerRoot;

        for (let i = 0; i < segmentCount; i++) {
          const joint = new THREE.Group();
          if (i > 0) {
            const prevScale = segmentScales[i - 1];
            joint.position.x = prevScale.width * SEGMENT_LENGTH;
          }

          const baseYOffset = (Math.random() - 0.5) * 0.06;
          joint.position.y = baseYOffset;
          joint.userData.baseY = baseYOffset;

          const mesh = new THREE.Mesh(triangleGeometry, triangleMaterial);
          const { width, height } = segmentScales[i];
          mesh.scale.set(width * SEGMENT_LENGTH, height, 1.0);
          mesh.position.set(0, 0, 0);

          joint.add(mesh);
          parent.add(joint);

          joints.push(joint);
          parent = joint;
        }

        currentSegmentCount = segmentCount;
        updateUI();
      }

      // === UI ===
      const addButton = document.getElementById("addJoint");
      const removeButton = document.getElementById("removeJoint");
      const jointInfo = document.getElementById("jointInfo");

      function updateUI() {
        jointInfo.textContent = `관절 개수: ${currentSegmentCount}`;
        addButton.disabled = currentSegmentCount >= MAX_SEGMENTS;
        removeButton.disabled = currentSegmentCount <= MIN_SEGMENTS;
      }

      addButton.addEventListener("click", () => {
        if (currentSegmentCount < MAX_SEGMENTS) {
          buildWalker(currentSegmentCount + 1);
        }
      });

      removeButton.addEventListener("click", () => {
        if (currentSegmentCount > MIN_SEGMENTS) {
          buildWalker(currentSegmentCount - 1);
        }
      });

      // 초기 상태: 힘겹게 걷는 느낌 (관절 적게)
      buildWalker(MIN_SEGMENTS);

      // === 애니메이션 루프 ===
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);

        const t = clock.getElapsedTime();

        // 워커 전체 위치 (걷는 동작)
        const travelSpeed = 1.25;
        const strideSpeed = 3.2;
        const loopWidth = 12;
        const stridePhase = t * strideSpeed;
        walkerRoot.position.x = ((t * travelSpeed) % loopWidth) - loopWidth / 2;
        walkerRoot.position.y = -1.4 + Math.sin(stridePhase * 0.5) * 0.22;
        walkerRoot.rotation.z = Math.sin(stridePhase * 0.25) * 0.05;

        const jointCount = joints.length;
        const divisor = Math.max(jointCount - 1, 1);

        joints.forEach((joint, i) => {
          const normalized = i / divisor;
          const alternatingPhase = i % 2 === 0 ? 0 : Math.PI;
          const gaitPhase = stridePhase + i * 0.25 + alternatingPhase;
          const swingStrength = 0.35 + normalized * 0.6;
          const liftStrength = (1 - normalized) * 0.22;
          const swing = Math.sin(gaitPhase) * swingStrength;
          const lift = Math.max(0, Math.sin(gaitPhase + Math.PI / 2));
          joint.rotation.z = swing;
          joint.position.y = (joint.userData.baseY || 0) + lift * liftStrength;
        });

        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
