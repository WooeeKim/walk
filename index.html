<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Triangle Walker - Button Version</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #f4f4f2;
        overflow: hidden;
      }
      canvas {
        display: block;
        position: fixed;
        inset: 0;
      }
      .ui {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 12px;
        z-index: 10;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      }
      button {
        padding: 8px 14px;
        border-radius: 999px;
        border: none;
        background: #111111;
        color: white;
        font-size: 14px;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.4;
        cursor: default;
      }
      .info {
        font-size: 14px;
        color: #111111;
        align-self: center;
      }
    </style>
  </head>
  <body>
    <div class="ui">
      <button id="addJoint">관절 하나 추가하기</button>
      <button id="removeJoint">관절 하나 빼기</button>
      <span class="info" id="jointInfo"></span>
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.164.0/build/three.module.js";

      // === 기본 세팅 ===
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf4f4f2);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const camera = new THREE.OrthographicCamera();
      scene.add(camera);

      function updateCamera() {
        const aspect = window.innerWidth / window.innerHeight;
        const viewSize = 6;
        camera.left   = -viewSize * aspect;
        camera.right  =  viewSize * aspect;
        camera.top    =  viewSize;
        camera.bottom = -viewSize;
        camera.near   = 0.1;
        camera.far    = 100;
        camera.position.set(0, 0, 10);
        camera.lookAt(0, 0, 0);
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      updateCamera();
      window.addEventListener("resize", updateCamera);

      // === 삼각형 지오메트리 & 머티리얼 ===
      function createTriangleGeometry() {
        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
          0,   0, 0,   // 왼쪽 아래(피벗)
          1.0, 0, 0,   // 오른쪽 아래
          0.5, 1.0, 0  // 위
        ]);
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(vertices, 3)
        );
        geometry.computeVertexNormals();
        return geometry;
      }

      const triangleGeometry = createTriangleGeometry();
      const triangleMaterial = new THREE.MeshBasicMaterial({
        color: 0x111111,
        side: THREE.DoubleSide
      });

      // === 워커(관절 체인) ===
      const walkerRoot = new THREE.Group();
      scene.add(walkerRoot);

      let joints = [];
      let currentSegmentCount = 0;
      const segmentConfigs = [];

      const MIN_SEGMENTS = 2;
      const MAX_SEGMENTS = 12;
      const SEGMENT_LENGTH = 1.0;

      function clearWalker() {
        walkerRoot.children.slice().forEach(child => {
          walkerRoot.remove(child);
        });
        joints = [];
      }

      function randomInRange(min, max) {
        return min + Math.random() * (max - min);
      }

      function ensureSegmentConfigs(count) {
        if (segmentConfigs.length > count) {
          segmentConfigs.length = count;
        }
        while (segmentConfigs.length < count) {
          segmentConfigs.push({
            width: randomInRange(0.6, 1.4),
            height: randomInRange(0.6, 1.5),
            rotationSpeed: randomInRange(1.5, 3.5),
            rotationAmplitude: randomInRange(0.35, 0.85),
            wobbleSpeed: randomInRange(0.8, 1.6),
            wobbleStrength: randomInRange(0.05, 0.25),
            lateralStrength: randomInRange(0.03, 0.12),
            phase: Math.random() * Math.PI * 2,
            baseYOffset: (Math.random() - 0.5) * 0.15
          });
        }
      }

      function createAnchors(widthScale, heightScale) {
        const anchors = [
          new THREE.Group(),
          new THREE.Group(),
          new THREE.Group()
        ];
        anchors[0].position.set(0, 0, 0);
        anchors[1].position.set(widthScale * SEGMENT_LENGTH, 0, 0);
        anchors[2].position.set(widthScale * SEGMENT_LENGTH * 0.5, heightScale, 0);
        return anchors;
      }

      function buildWalker(segmentCount) {
        clearWalker();
        ensureSegmentConfigs(segmentCount);

        for (let i = 0; i < segmentCount; i++) {
          const config = segmentConfigs[i];
          const joint = new THREE.Group();
          joint.position.set(0, 0, 0);
          const mesh = new THREE.Mesh(triangleGeometry, triangleMaterial);
          const { width, height } = config;
          mesh.scale.set(width * SEGMENT_LENGTH, height, 1.0);
          mesh.position.set(0, 0, 0);

          joint.add(mesh);
          const anchors = createAnchors(width, height);
          anchors.forEach(anchor => joint.add(anchor));
          joint.userData.anchors = anchors;
          joint.userData.config = config;
          joint.userData.offset = {
            x: (Math.random() - 0.5) * 0.05,
            y: config.baseYOffset
          };

          if (i === 0) {
            walkerRoot.add(joint);
          } else {
            const parentIndex = Math.floor(Math.random() * i);
            const parentJoint = joints[parentIndex];
            const anchorIndex = Math.floor(Math.random() * 3);
            const parentAnchor =
              parentJoint.userData.anchors[anchorIndex] || parentJoint;
            parentAnchor.add(joint);
          }

          joints.push(joint);
        }

        currentSegmentCount = segmentCount;
        updateUI();
      }

      // === UI ===
      const addButton = document.getElementById("addJoint");
      const removeButton = document.getElementById("removeJoint");
      const jointInfo = document.getElementById("jointInfo");

      function updateUI() {
        jointInfo.textContent = `관절 개수: ${currentSegmentCount}`;
        addButton.disabled = currentSegmentCount >= MAX_SEGMENTS;
        removeButton.disabled = currentSegmentCount <= MIN_SEGMENTS;
      }

      addButton.addEventListener("click", () => {
        if (currentSegmentCount < MAX_SEGMENTS) {
          buildWalker(currentSegmentCount + 1);
        }
      });

      removeButton.addEventListener("click", () => {
        if (currentSegmentCount > MIN_SEGMENTS) {
          buildWalker(currentSegmentCount - 1);
        }
      });

      // 초기 상태: 힘겹게 걷는 느낌 (관절 적게)
      buildWalker(MIN_SEGMENTS);

      // === 애니메이션 루프 ===
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);

        const t = clock.getElapsedTime();

        // 워커 전체 위치 및 롤링
        const travelSpeed = 1.5;
        const loopWidth = 14;
        const strideSpeed = 2.8;
        const rollSpeed = 1.2;
        const stridePhase = t * strideSpeed;
        walkerRoot.position.x = ((t * travelSpeed) % loopWidth) - loopWidth / 2;
        walkerRoot.position.y = -1.45 + Math.sin(stridePhase * 0.5) * 0.35;
        walkerRoot.rotation.z =
          Math.sin(stridePhase) * 0.35 + stridePhase * 0.05;
        walkerRoot.rotation.x = Math.cos(rollSpeed * t) * 0.1;
        walkerRoot.rotation.y = Math.sin(rollSpeed * 0.7 * t) * 0.18;

        joints.forEach((joint, i) => {
          const config = joint.userData.config;
          if (!config) return;
          const swingPhase = stridePhase * config.rotationSpeed + config.phase;
          const rattlePhase = t * config.wobbleSpeed + config.phase;
          const swing = Math.sin(swingPhase) * config.rotationAmplitude;
          joint.rotation.z = swing;
          const wobbleY = Math.sin(rattlePhase) * config.wobbleStrength;
          const wobbleX = Math.cos(rattlePhase) * config.lateralStrength;
          joint.position.y = (joint.userData.offset?.y || 0) + wobbleY;
          joint.position.x = (joint.userData.offset?.x || 0) + wobbleX;
        });

        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
